<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: 417eda23c69cc5d6814e66c97437d3d62270baf1 Maintainer: nobody Status: working -->
<sect1 xml:id="language.types.string">
 <title>Strings (Zeichenketten)</title>

 <para>
  Ein <type>String</type> stellt eine Kette von Zeichen dar indem ein Zeichen
  gleichbedeutend mit einem Byte ist. Das bedeutet, es gibt exakt 256 mögliche
  Zeichen. Es impliziert zudem, dass PHP keine native Unterstützung von
  Unicode bietet. Siehe auch
  <link linkend="language.types.string.details">Details des String-Typs</link>.
 </para>

 <note>
  <simpara>
   Unter 32-bit-Versionen kann ein <type>String</type>) bis zu 2GB (maximal
   2147483647 bytes) groß werden.
  </simpara>
 </note>

 <sect2 xml:id="language.types.string.syntax">
  <title>Syntax</title>

  <para>
   Ein <type>String</type>-Literal kann auf vier unterschiedliche Arten
   spezifiziert werden:
  </para>

  <itemizedlist>
   <listitem>
    <simpara>
     <link linkend="language.types.string.syntax.single">einfache Anführungszeichen</link>
    </simpara>
   </listitem>
   <listitem>
    <simpara>
     <link linkend="language.types.string.syntax.double">doppelte Anführungszeichen</link>
    </simpara>
   </listitem>
   <listitem>
    <simpara>
     <link linkend="language.types.string.syntax.heredoc">Heredoc-Syntax</link>
    </simpara>
   </listitem>
   <listitem>
    <simpara>
     <link linkend="language.types.string.syntax.nowdoc">Nowdoc-Syntax</link>
    </simpara>
   </listitem>
  </itemizedlist>

  <sect3 xml:id="language.types.string.syntax.single">
   <title>Einfache Anführungszeichen</title>

   <para>
    Der einfachste Weg einen <type>String</type> zu spezifizieren, ist ihn mit
    einfachen Anführungszeichen (das Zeichen <literal>'</literal>) zu
    umschließen.
   </para>

   <para>
    Um ein einfaches Anführungszeichen hierin anzugeben, fügen sie einen
    Backslash (<literal>\</literal>) vor dem Zeichen ein. Um einen Backslash
    als Zeichen anzugeben, verdoppeln Sie ihn (<literal>\\</literal>).  Alle
    anderen Instanzen von Backslash werden als buchstäblicher Backslash
    behandelt: Das bedeutet, dass die anderen Escape-Sequenzen, die Sie
    vielleicht gewohnt sind, wie <literal>\r</literal> oder
    <literal>\n</literal>, buchstäblich wie angegeben ausgegeben werden und
    keine besondere Bedeutung haben.
   </para>

   <note>
    <simpara>
     Im Gegensatz zu den
     <link linkend="language.types.string.syntax.double">doppelten Anführungszeichen</link>- und
     <link linkend="language.types.string.syntax.heredoc">Heredoc</link>-Notationen
     werden <link linkend="language.variables">Variablen</link> und
     Escape-Sequenzen für Sonderzeichen <emphasis>nicht</emphasis> maskiert
     (ersetzt), wenn sie in einem mit einfachen Anführungszeichen umschlossenen
     <type>String</type> erscheinen.
    </simpara>
   </note>

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
echo 'dies ist ein einfacher String';

echo 'Sie können auch Zeilenumbrüche
in dieser Art angeben,
dies ist okay so';

// Gibt aus: Arnold sagte einst: "I'll be back"
echo 'Arnold sagte einst: "I\'ll be back"';

// Ausgabe: Sie löschten C:\*.*?
echo 'Sie löschten C:\\*.*?';

// Ausgabe: Sie löschten C:\*.*?
echo 'Sie löschten C:\*.*?';

// Ausgabe: Dies erzeugt keinen: \n Zeilenumbruch
echo 'Dies erzeugt keinen: \n Zeilenumbruch';

// Ausgabe: Variablen werden $ebenfalls $nicht ersetzt
echo 'Variablen werden $ebenfalls $nicht ersetzt';
?>
]]>
    </programlisting>
   </informalexample>

  </sect3>

  <sect3 xml:id="language.types.string.syntax.double">
   <title>Doppelte Anführungszeichen</title>

   <para>
    Wenn der <type>String</type> in doppelte Anführungszeichen
    (<literal>"</literal>) eingeschlossen wird, interpretiert PHP zusätzliche
    Escape-Sequenzen für Sonderzeichen:
   </para>

   <table>
    <title>Maskierte Zeichen</title>

    <tgroup cols="2">
     <thead>
      <row>
       <entry>Sequenz</entry>
       <entry>Bedeutung</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry><literal>\n</literal></entry>
       <entry>Zeilenumbruch (LF or 0x0A (10) in ASCII)</entry>
      </row>
      <row>
       <entry><literal>\r</literal></entry>
       <entry>Wagenrücklauf (CR or 0x0D (13) in ASCII)</entry>
      </row>
      <row>
       <entry><literal>\t</literal></entry>
       <entry>horizontaler Tabulator (HT or 0x09 (9) in ASCII)</entry>
      </row>
      <row>
       <entry><literal>\v</literal></entry>
       <entry>vertikaler Tabulator (VT or 0x0B (11) in ASCII)</entry>
      </row>
      <row>
       <entry><literal>\e</literal></entry>
       <entry>Escape-Zeichen (ESC or 0x1B (27) in ASCII)</entry>
      </row>
      <row>
       <entry><literal>\f</literal></entry>
       <entry>Seitenvorschub (FF or 0x0C (12) in ASCII)</entry>
      </row>
      <row>
       <entry><literal>\\</literal></entry>
       <entry>Backslash (Rückstrich)</entry>
      </row>
      <row>
       <entry><literal>\$</literal></entry>
       <entry>Dollar-Zeichen</entry>
      </row>
      <row>
       <entry><literal>\"</literal></entry>
       <entry>doppeltes Anführungszeichen</entry>
      </row>
      <row>
       <entry><literal>\[0-7]{1,3}</literal></entry>
       <entry>
        die Folge von Zeichen, die auf den regulären Ausdruck passt, ist ein
        Zeichen in oktaler Notation, die stillschweigend überläuft, um in ein
        Byte zu passen (z. B. "\400" === "\000")
       </entry>
      </row>
      <row>
       <entry><literal>\x[0-9A-Fa-f]{1,2}</literal></entry>
       <entry>
        die Folge von Zeichen, die auf den regulären Ausdruck passt, ist ein
        Zeichen in hexadezimaler Schreibweise
       </entry>
      </row>
      <row>
       <entry><literal>\u{[0-9A-Fa-f]+}</literal></entry>
       <entry>
        die Folge von Zeichen, die auf den regulären Ausdruck passt, ist ein
        Unicode-Codepunkt, der in der Zeichenkette als UTF-8-Darstellung des
        Codepunkts ausgegeben wird
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>
    Wie bei <type>String</type>s in einfachen Anführungszeichen wird beim
    maskieren aller anderen Zeichen der Backslash mit ausgegeben.
   </para>

   <para>
    Das Expandieren von Variablen-Namen ist eine der wichtigsten Besonderheiten
    von in doppelten Anführungszeichen angegebenen <type>String</type>s. Siehe
    hierzu <link linkend="language.types.string.parsing">String-Parsing</link>
    für weitere Details.
   </para>
  </sect3>

  <sect3 xml:id="language.types.string.syntax.heredoc">
   <title>Heredoc</title>

   <simpara>
    Eine dritte Möglichkeit <type>String</type>s zu begrenzen, stellt die
    Heredoc-Syntax dar: <literal>&lt;&lt;&lt;</literal>. Nach diesem Operator
    wird ein beliebiger Bezeichner angegeben, dann eine neue Zeile. Hiernach
    folgt der eigentliche <type>String</type> und abschließend erneut der
    Bezeichner, um die Auszeichnung abzuschließen.
   </simpara>

   <simpara>
    Der schließende Bezeichner <emphasis>muss</emphasis> in der ersten Spalte
    der Zeile beginnen. Zudem muss dieser sich an dieselben Namensregeln wie
    jede andere Kennung in PHP halten: es darf nur alphanumerische Zeichen und
    den Unterstrich enthalten und muss mit einem Buchstaben oder dem Unterstrich
    beginnen.
   </simpara>

   <simpara>
    Außerdem muss der schließende Bezeichner den gleichen Benennungsregeln
    folgen wie jeder andere Bezeichner in PHP: Er darf nur alphanumerische
    Zeichen und enthalten und muss mit einem nicht-numerischen Zeichen oder
    einem Unterstrich beginnen.
   </simpara>

   <example>
    <title>Grundlegendes Heredoc-Beispiel ab PHP 7.3.0</title>
    <programlisting role="php">
<![CDATA[
<?php
// keine Einrückung
echo <<<END
      a
     b
    c
\n
END;

// vier Leerzeichen Einrückung
echo <<<END
      a
     b
    c
    END;
]]>
    </programlisting>
    &example.outputs.73;
    <screen>
<![CDATA[
      a
     b
    c

  a
 b
c
]]>
    </screen>
   </example>

   <simpara>
    Wenn der schließende Bezeichner weiter eingerückt ist als alle Zeilen des
    Textkörpers, wird ein <classname>ParseError</classname> ausgelöst:
   </simpara>

   <example>
    <title>Der schließende Bezeichner darf nicht weiter eingerückt sein, als die Zeilen des Textkörpers</title>
    <programlisting role="php">
<![CDATA[
<?php
echo <<<END
  a
 b
c
   END;
]]>
    </programlisting>
    &example.outputs.73;
    <screen>
<![CDATA[
PHP Parse error:  Invalid body indentation level (expecting an indentation level of at least 3) in example.php on line 4
]]>
    </screen>
   </example>

   <simpara>
    Wenn der schließende Bezeichner eingerückt ist, können auch Tabulatoren
    verwendet werden, allerdings dürfen Tabulatoren und Leerzeichen
    in Bezug auf die Einrückung des schließenden Bezeichners und die
    Einrückung des Textkörpers (bis zum schließenden Bezeichner)
    <emphasis>nicht</emphasis> miteinander vermischt werden. In jedem dieser
    Fälle wird ein <classname>ParseError</classname> ausgelöst. Diese
    Whitespace-Einschränkungen wurden aufgenommen, weil die Vermischung von
    Tabulatoren und Leerzeichen für die Einrückung die Lesbarkeit
    beeinträchtigt.
   </simpara>

   <example>
    <title>Unterschiedliche Einrückung für den Bezeichner, der den Textkörper (Leerzeichen) schließt</title>
    <programlisting role="php">
<![CDATA[
<?php
// Der gesamte folgende Code funktioniert nicht.

// Unterschiedliche Einrückung für den Bezeichner (Tabulatoren), der den
// Textkörper (Leerzeichen) schließt
{
	echo <<<END
	 a
		END;
}

// Vermischung von Leerzeichen und Tabulatoren im Textkörper
{
    echo <<<END
    	a
     END;
}

// Vermischung von Leerzeichen und Tabulatoren in der Endmarkierung
{
	echo <<<END
		  a
		 END;
}
]]>
    </programlisting>
    &example.outputs.73;
    <screen>
<![CDATA[
PHP Parse error:  Invalid indentation - tabs and spaces cannot be mixed in example.php line 8
]]>
    </screen>
   </example>

   <simpara>
    Der schließende Bezeichner für den Textkörper muss nicht von einem
    Semikolon oder Zeilenumbruch gefolgt werden. Zum Beispiel ist der folgende
    Code ist ab PHP 7.3.0 erlaubt:
   </simpara>

   <example>
    <title>Fortsetzen eines Ausdrucks nach einem schließenden Bezeichner</title>
    <programlisting role="php">
<![CDATA[
<?php
$values = [<<<END
a
  b
    c
END, 'd e f'];
var_dump($values);
]]>
    </programlisting>
    &example.outputs.73;
    <screen>
<![CDATA[
array(2) {
  [0] =>
  string(11) "a
  b
    c"
  [1] =>
  string(5) "d e f"
}
]]>
    </screen>
   </example>

   <warning>
    <simpara>
     Wenn der schließende Bezeichner am Anfang einer Zeile gefunden wurde,
     dann kann er unabhängig davon, ob er Teil eines anderen Wortes war, als
     schließender Bezeichner betrachtet werden und führt zu einem
     <classname>ParseError</classname>.
    </simpara>

    <example>
     <title>Ein schließender Bezeichner im Textkörper der Zeichenkette führt zu einem ParseError</title>
     <programlisting role="php">
<![CDATA[
<?php
$values = [<<<END
a
b
END ING
END, 'd e f'];
]]>
     </programlisting>
     &example.outputs.73;
    <screen>
<![CDATA[
PHP Parse error:  syntax error, unexpected identifier "ING", expecting "]" in example.php on line 6
]]>
     </screen>
    </example>

    <simpara>
     Um dieses Problem zu vermeiden, ist es ratsam, die einfache Regel zu
     befolgen: <emphasis>Wählen Sie nicht den schließenden Bezeichner, der im
     Textkörper erscheint</emphasis>.
    </simpara>

   </warning>

   <warning>
    <simpara>
     Vor PHP 7.3.0 ist es sehr wichtig, darauf zu achten, dass die Zeile mit
     dem schließenden Bezeichner keine anderen Zeichen außer einem Semikolon
     (<literal>;</literal>) enthalten darf. Das heißt insbesondere auch, dass
     der Bezeichner nicht <emphasis>eingerückt werden darf</emphasis> und dass
     es vor oder nach dem Semikolon auch keine Leerzeichen oder Tabulatoren
     geben darf. Zudem muss das erste Zeichen vor dem schließenden Bezeichner
     ein Zeilenumbruch sein, so wie er vom Betriebssystem definiert wird. In
     UNIX-Systemen, inlusive macOS, ist dies <literal>\n</literal>. Auf den
     schließenden Bezeichner muss ebenfalls ein Zeilenumbruch folgen.
    </simpara>

    <simpara>
     Wenn diese Regel gebrochen wird und der schließende Bezeichner nicht valide
     ist, wird er nicht als Bezeichner angenommen und PHP wird weiter nach einem
     solchen schließenden Bezeichner suchen. Wird kein gültiger schließender
     Bezeichner vor dem Dateiende gefunden, gibt PHP einen auf die letzte Zeile
     der Datei weisenden Parser-Fehler aus.
    </simpara>

    <example>
     <title>Ungültiges Beispiel</title>
     <programlisting role="php">
      <!-- This is an INVALID example -->
<![CDATA[
<?php
class foo {
    public $bar = <<<EOT
bar
    EOT;
}
// Identifier must not be indented
?>
]]>
     </programlisting>
    </example>
    <example>
     <title>Gültiges Beispiel</title>
     <programlisting role="php">
      <!-- This is a VALID example -->
<![CDATA[
<?php
class foo {
    public $bar = <<<EOT
bar
EOT;
}
?>
]]>
     </programlisting>
    </example>

    <para>
     Heredocs, die Variablen enthalten, können nicht für die Initialisierung
     von Klasseneigenschaften verwendet werden.
    </para>

   </warning>

   <para>
    Heredoc-Text verhält sich genau wie ein <type>String</type> in doppelten
    Anführungsstrichen, ohne die doppelten Anführungszeichen. Das bedeutet,
    dass Anführungszeichen in einem Heredoc nicht maskiert werden müssen, aber
    die oben aufgeführten Maskierungscodes können trotzdem verwendet werden.
    Variablen werden aufgelöst, aber wenn komplexe Variablen innerhalb eines
    Heredocs verwendet werden, ist die gleiche Vorsicht geboten wie bei
    <type>String</type>s.
   </para>

   <example>
    <title>Beispiel für das Notieren von Heredoc-Strings</title>
    <programlisting role="php">
<![CDATA[
<?php
$str = <<<EOD
Ein Beispiel für einen String, der sich 
unter Verwendung der heredoc-Syntax
über mehrere Zeilen erstreckt.
EOD;

/* Ein komplexeres Beispiel mit Variablen. */
class foo
{
    var $foo;
    var $bar;

    function __construct()
    {
        $this->foo = 'Foo';
        $this->bar = array('Bar1', 'Bar2', 'Bar3');
    }
}

$foo = new foo();
$name = 'MeinName';

echo <<<EOT
Mein Name ist "$name". Ich gebe etwas $foo->foo aus.
Jetzt gebe ich etwas {$foo->bar[1]} aus.
Dies sollte ein großes 'A' ausgeben: \x41
EOT;
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
Mein Name ist "MeinName". Ich gebe etwas Foo aus.
Jetzt gebe ich etwas Bar2 aus.
Dies sollte ein großes 'A' ausgeben: A]]>
    </screen>
   </example>

   <para>
    Es ist auch möglich, die Heredoc-Syntax zu verwenden, um Daten an
    Funktionsargumente zu übergeben:
   </para>

   <example>
    <title>Beispiel für Heredoc in Argumenten</title>
    <programlisting role="php">
<![CDATA[
<?php
var_dump(array(<<<EOD
foobar!
EOD
));
?>
]]>
    </programlisting>
   </example>

   <para>
    Es ist möglich, statische Variablen und Klasseneigenschaften/Konstanten
    mit Hilfe der Heredoc-Syntax zu initialisieren:
   </para>

   <example>
    <title>Verwendung von Heredoc zur Initialisierung von statischen Werten</title>
    <programlisting role="php">
<![CDATA[
<?php
// Statische Variablen
function foo()
{
    static $bar = <<<LABEL
Hier steht nichts drin...
LABEL;
}

// Klasseneigenschaften/Konstanten
class foo
{
    const BAR = <<<FOOBAR
Beispiel für eine Konstante
FOOBAR;

    public $baz = <<<FOOBAR
Beispiel für eine Eigenschaft
FOOBAR;
}
?>
]]>
    </programlisting>
   </example>

   <para>
    Der öffnende Heredoc-Bezeichner kann optional in doppelte
    Anführungszeichen gesetzt werden:
   </para>

   <example>
    <title>Verwendung von doppelten Anführungszeichen in Heredoc</title>
    <programlisting role="php">
<![CDATA[
<?php
echo <<<"FOOBAR"
Hallo Welt!
FOOBAR;
?>
]]>
    </programlisting>
   </example>

  </sect3>

  <sect3 xml:id="language.types.string.syntax.nowdoc">
   <title>Nowdoc</title>

   <para>
    Nowdocs sind für Strings in einfachen Anführungszeichen das, was
    Heredocs für Strings in doppelten Anführungszeichen sind. Ein Nowdoc wird ähnlich wie ein Heredoc angegeben, aber es wird <emphasis>kein Parsing</emphasis> innerhalb eines Nowdocs durchgeführt. Das Konstrukt ist ideal für die 
    Einbettung von PHP-Code oder anderen großen Textblöcken ohne maskieren zu müssen.
    Es hat einige Eigenschaften mit dem <literal>&lt;![CDATA[ ]]&gt;</literal>-Konstrukt in SGML gemeinsam, indem es einen Textblock deklariert, der nicht geparst werden soll.
   </para>

   <para>
    Ein Nowdoc wird mit der gleichen <literal>&lt;&lt;&lt;</literal>-Sequenz identifiziert, die für Heredocs verwendet wird, aber der nachfolgende Bezeichner wird in
    einfachen Anführungszeichen eingeschlossen, z. B. <literal>&lt;&lt;&lt;'EOT'</literal>. Alle Regeln für
    Heredoc-Bezeichner gelten auch für Nowdoc-Bezeichner, insbesondere die
    hinsichtlich des Aussehens des schließenden Bezeichners.
   </para>

   <example>
    <title>Nowdoc-Beispiel für das Notieren von Strings</title>
    <programlisting role="php">
<![CDATA[
<?php
echo <<<'EOD'
Ein Beispiel für einen String, der sich über mehrere Zeilen erstreckt
unter Verwendung der Nowdoc-Syntax. Backslashes werden immer als
Buchstaben behandelt,
z. B. \\ und \'.
EOD;
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
Ein Beispiel für einen String, der sich über mehrere Zeilen erstreckt
unter Verwendung der Nowdoc-Syntax. Backslashes werden immer als
Buchstaben behandelt,
z. B. \\ und \'.
]]>
    </screen>
   </example>

   <example>
    <title>Nowdoc Beispiel für Strings mit Variablen</title>
    <programlisting role="php">
<![CDATA[
<?php
class foo
{
    public $foo;
    public $bar;

    function __construct()
    {
        $this->foo = 'Foo';
        $this->bar = array('Bar1', 'Bar2', 'Bar3');
    }
}

$foo = new foo();
$name = 'MeinName';

echo <<<'EOT'
Mein Name ist "$name". Ich gebe etwas $foo->foo aus.
Jetzt gebe ich etwas {$foo->bar[1]} aus.
Dies sollte ein großes 'A' ausgeben: \x41
EOT;
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
Mein Name ist "$name". Ich gebe etwas $foo->foo aus.
Jetzt gebe ich etwas {$foo->bar[1]} aus.
Dies sollte ein großes 'A' ausgeben: \x41]]>
    </screen>
   </example>

   <example>
    <title>Beispiel für statische Daten</title>
    <programlisting role="php">
<![CDATA[
<?php
class foo {
    public $bar = <<<'EOT'
bar
EOT;
}
?>
]]>
    </programlisting>
   </example>

  </sect3>

  <sect3 xml:id="language.types.string.parsing">
   <title>Parsing (Analyse) von Variablen</title>

   <simpara>
    Wenn ein <type>string</type> in doppelten Anführungszeichen oder mit
    Heredoc angegeben wird, werden darin
    <link linkend="language.variables">Variablen</link> geparst.
   </simpara>

   <simpara>
    Es gibt zwei Arten von Syntax: eine
    <link linkend="language.types.string.parsing.simple">einfache</link> und
    eine <link linkend="language.types.string.parsing.complex">komplexe</link>
    Syntax. Die einfache Syntax ist die gebräuchlichste und bequemste. Sie
    bietet eine Möglichkeit, eine Variable, einen <type>&array;</type>-Wert
    oder eine <type>&object;</type>-Eigenschaft mit minimalem Aufwand in einen
    <type>String</type> einzubetten.
   </simpara>

   <simpara>
    Die komplexe Syntax erkennt man an den geschweifte Klammern, die den
    Ausdruck umgeben.
   </simpara>

   <sect4 xml:id="language.types.string.parsing.simple">
    <title>Einfache Syntax</title>

    <simpara>
     Wenn ein Dollarzeichen (<literal>$</literal>) vorkommt, nimmt der Parser
     gierig so viele Token wie möglich, um einen gültigen Variablennamen zu
     bilden. Schließen Sie den Variablennamen in geschweifte Klammern ein, um
     das Ende des Namens explizit anzugeben.
    </simpara>

    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$juice = "apple";

echo "He drank some $juice juice.".PHP_EOL;
// Ungültig. "s" ist ein gültiges Zeichen für einen Variablennamen, aber die
// Variable ist $juice.
echo "He drank some juice made of $juices.";
// Gültig. Geben Sie das Ende des Variablennamens explizit an, indem Sie ihn
// in geschweifte Klammern einschließen:
echo "He drank some juice made of ${juice}s.";
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
He drank some apple juice.
He drank some juice made of .
He drank some juice made of apples.
]]>
     </screen>
    </informalexample>

    <simpara>
     In ähnlicher Weise kann ein <type>&array;</type>-Index oder eine
     <type>&object;</type>-Eigenschaft geparst werden. Bei Array-Indizes
     markiert die schließende eckige Klammer (<literal>]</literal>) das Ende
     des Indexes. Für Objekteigenschaften gelten die gleichen Regeln wie für
     einfache Variablen.
    </simpara>

    <example>
     <title>Beispiel für einfache Syntax</title>
     <programlisting role="php">
<![CDATA[
<?php
$juices = array("apple", "orange", "koolaid1" => "purple");

echo "He drank some $juices[0] juice.".PHP_EOL;
echo "He drank some $juices[1] juice.".PHP_EOL;
echo "He drank some $juices[koolaid1] juice.".PHP_EOL;

class people {
    public $john = "John Smith";
    public $jane = "Jane Smith";
    public $robert = "Robert Paulsen";

    public $smith = "Smith";
}

$people = new people();

echo "$people->john drank some $juices[0] juice.".PHP_EOL;
echo "$people->john then said hello to $people->jane.".PHP_EOL;
echo "$people->john's wife greeted $people->robert.".PHP_EOL;
echo "$people->robert greeted the two $people->smiths."; // Won't work
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
He drank some apple juice.
He drank some orange juice.
He drank some purple juice.
John Smith drank some apple juice.
John Smith then said hello to Jane Smith.
John Smith's wife greeted Robert Paulsen.
Robert Paulsen greeted the two .
]]>
     </screen>
    </example>

    <simpara>
     As of PHP 7.1.0 also <emphasis>negative</emphasis> numeric indices are
     supported.
    </simpara>

    <example><title>Negative numeric indices</title>
     <programlisting role="php">
<![CDATA[
<?php
$string = 'string';
echo "The character at index -2 is $string[-2].", PHP_EOL;
$string[-3] = 'o';
echo "Changing the character at index -3 to o gives $string.", PHP_EOL;
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
The character at index -2 is n.
Changing the character at index -3 to o gives strong.
]]>
     </screen>
    </example>

    <simpara>
     For anything more complex, you should use the complex syntax.
    </simpara>
   </sect4>

   <sect4 xml:id="language.types.string.parsing.complex">
    <title>Complex (curly) syntax</title>

    <simpara>
     This isn't called complex because the syntax is complex, but because it
     allows for the use of complex expressions.
    </simpara>

    <simpara>
     Any scalar variable, array element or object property with a
     <type>string</type> representation can be included via this syntax.
     Simply write the expression the same way as it would appear outside the
     <type>string</type>, and then wrap it in <literal>{</literal> and
     <literal>}</literal>. Since <literal>{</literal> can not be escaped, this
     syntax will only be recognised when the <literal>$</literal> immediately
     follows the <literal>{</literal>. Use <literal>{\$</literal> to get a
     literal <literal>{$</literal>. Some examples to make it clear:
    </simpara>

    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
// Show all errors
error_reporting(E_ALL);

$great = 'fantastic';

// Won't work, outputs: This is { fantastic}
echo "This is { $great}";

// Works, outputs: This is fantastic
echo "This is {$great}";

// Works
echo "This square is {$square->width}00 centimeters broad.";


// Works, quoted keys only work using the curly brace syntax
echo "This works: {$arr['key']}";


// Works
echo "This works: {$arr[4][3]}";

// This is wrong for the same reason as $foo[bar] is wrong  outside a string.
// In other words, it will still work, but only because PHP first looks for a
// constant named foo; an error of level E_NOTICE (undefined constant) will be
// thrown.
echo "This is wrong: {$arr[foo][3]}";

// Works. When using multi-dimensional arrays, always use braces around arrays
// when inside of strings
echo "This works: {$arr['foo'][3]}";

// Works.
echo "This works: " . $arr['foo'][3];

echo "This works too: {$obj->values[3]->name}";

echo "This is the value of the var named $name: {${$name}}";

echo "This is the value of the var named by the return value of getName(): {${getName()}}";

echo "This is the value of the var named by the return value of \$object->getName(): {${$object->getName()}}";

// Won't work, outputs: This is the return value of getName(): {getName()}
echo "This is the return value of getName(): {getName()}";
?>
]]>
<!-- maybe it's better to leave this out??
// this works, but i disencourage its use, since this is NOT
// involving functions, rather than mere variables, arrays and objects.
$beer = 'Heineken';
echo "I'd like to have another {${ strrev('reeb') }}, hips";
 -->
     </programlisting>
    </informalexample>

    <para>
     It is also possible to access class properties using variables
     within strings using this syntax.
    </para>

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
class foo {
    var $bar = 'I am bar.';
}

$foo = new foo();
$bar = 'bar';
$baz = array('foo', 'bar', 'baz', 'quux');
echo "{$foo->$bar}\n";
echo "{$foo->{$baz[1]}}\n";
?>
]]>
    </programlisting>
   &example.outputs;
   <screen>
<![CDATA[
I am bar.
I am bar.
]]>
   </screen>
   </informalexample>

    <note>
     <para>
      The value accessed from functions, method calls, static class variables,
      and class constants inside
      <literal>{$}</literal> will be interpreted as the name
      of a variable in the scope in which the string is defined. Using
      single curly braces (<literal>{}</literal>) will not work for
      accessing the return values of functions or methods or the
      values of class constants or static class variables.
     </para>
    </note>

    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
// Show all errors.
error_reporting(E_ALL);

class beers {
    const softdrink = 'rootbeer';
    public static $ale = 'ipa';
}

$rootbeer = 'A & W';
$ipa = 'Alexander Keith\'s';

// This works; outputs: I'd like an A & W
echo "I'd like an {${beers::softdrink}}\n";

// This works too; outputs: I'd like an Alexander Keith's
echo "I'd like an {${beers::$ale}}\n";
?>
]]>
     </programlisting>
    </informalexample>

   </sect4>
  </sect3>

  <sect3 xml:id="language.types.string.substr">
   <title>String access and modification by character</title>

   <para>
    Characters within <type>string</type>s may be accessed and modified by
    specifying the zero-based offset of the desired character after the
    <type>string</type> using square <type>array</type> brackets, as in
    <varname>$str[42]</varname>. Think of a <type>string</type> as an
    <type>array</type> of characters for this purpose. The functions
    <function>substr</function> and <function>substr_replace</function>
    can be used when you want to extract or replace more than 1 character.
   </para>

   <note>
    <simpara>
     As of PHP 7.1.0, negative string offsets are also supported. These specify
     the offset from the end of the string.
     Formerly, negative offsets emitted <constant>E_NOTICE</constant> for reading
     (yielding an empty string) and <constant>E_WARNING</constant> for writing
     (leaving the string untouched).
    </simpara>
   </note>

   <note>
    <simpara>
     Prior to PHP 8.0.0, <type>string</type>s could also be accessed using braces, as in
     <varname>$str{42}</varname>, for the same purpose.
     This curly brace syntax was deprecated as of PHP 7.4.0 and no longer supported as of PHP 8.0.0.
    </simpara>
   </note>

   <warning>
    <simpara>
     Writing to an out of range offset pads the string with spaces.
     Non-integer types are converted to integer.
     Illegal offset type emits <constant>E_WARNING</constant>.
     Only the first character of an assigned string is used.
     As of PHP 7.1.0, assigning an empty string throws a fatal error. Formerly,
     it assigned a NULL byte.
    </simpara>
   </warning>

   <warning>
    <simpara>
     Internally, PHP strings are byte arrays. As a result, accessing or
     modifying a string using array brackets is not multi-byte safe, and
     should only be done with strings that are in a single-byte encoding such
     as ISO-8859-1.
    </simpara>
   </warning>

   <note>
    <simpara>
     As of PHP 7.1.0, applying the empty index operator on an empty string throws a fatal
     error. Formerly, the empty string was silently converted to an array.
    </simpara>
   </note>

   <example>
    <title>Some string examples</title>
    <programlisting role="php">
<![CDATA[
<?php
// Get the first character of a string
$str = 'This is a test.';
$first = $str[0];

// Get the third character of a string
$third = $str[2];

// Get the last character of a string.
$str = 'This is still a test.';
$last = $str[strlen($str)-1];

// Modify the last character of a string
$str = 'Look at the sea';
$str[strlen($str)-1] = 'e';

?>
]]>
    </programlisting>
   </example>

   <para>
    String offsets have to either be integers or integer-like strings,
    otherwise a warning will be thrown.
   </para>

   <example>
    <!-- TODO Update for PHP 8.0 -->
    <title>Example of Illegal String Offsets</title>
    <programlisting role="php">
<![CDATA[
<?php
$str = 'abc';

var_dump($str['1']);
var_dump(isset($str['1']));

var_dump($str['1.0']);
var_dump(isset($str['1.0']));

var_dump($str['x']);
var_dump(isset($str['x']));

var_dump($str['1x']);
var_dump(isset($str['1x']));
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
string(1) "b"
bool(true)

Warning: Illegal string offset '1.0' in /tmp/t.php on line 7
string(1) "b"
bool(false)

Warning: Illegal string offset 'x' in /tmp/t.php on line 9
string(1) "a"
bool(false)
string(1) "b"
bool(false)
]]>
    </screen>
   </example>

   <note>
    <para>
     Accessing variables of other types (not including arrays or objects
     implementing the appropriate interfaces) using <literal>[]</literal> or
     <literal>{}</literal> silently returns &null;.
    </para>
   </note>

   <note>
    <para>
     Characters within string literals can be accessed
     using <literal>[]</literal> or <literal>{}</literal>.
    </para>
   </note>

   <note>
    <para>
     Accessing characters within string literals using the
     <literal>{}</literal> syntax has been deprecated in PHP 7.4.
     This has been removed in PHP 8.0.
    </para>
   </note>
  </sect3>
 </sect2><!-- end syntax -->

 <sect2 xml:id="language.types.string.useful-funcs">
  <title>Useful functions and operators</title>

  <para>
   <type>String</type>s may be concatenated using the '.' (dot) operator. Note
   that the '+' (addition) operator will <emphasis>not</emphasis> work for this.
   See <link linkend="language.operators.string">String operators</link> for
   more information.
  </para>

  <para>
   There are a number of useful functions for <type>string</type> manipulation.
  </para>

  <simpara>
   See the <link linkend="ref.strings">string functions section</link> for
   general functions, and the <link linkend="ref.pcre">Perl-compatible regular
   expression functions</link> for advanced find &amp; replace functionality.
  </simpara>

  <simpara>
   There are also <link linkend="ref.url">functions for URL strings</link>, and
   functions to encrypt/decrypt strings
   (<link linkend="ref.sodium">Sodium</link> and
   <link linkend="ref.hash">Hash</link>).
  </simpara>

  <simpara>
   Finally, see also the <link linkend="ref.ctype">character type
   functions</link>.
  </simpara>
 </sect2>

 <sect2 xml:id="language.types.string.casting">
  <title>Converting to string</title>

  <para>
   A value can be converted to a <type>string</type> using the
   <literal>(string)</literal> cast or the <function>strval</function> function.
   <type>String</type> conversion is automatically done in the scope of an
   expression where a <type>string</type> is needed. This happens when using the
   <function>echo</function> or <function>print</function> functions, or when a
   variable is compared to a <type>string</type>. The sections on
   <link linkend="language.types">Types</link> and
   <link linkend="language.types.type-juggling">Type Juggling</link> will make
   the following clearer. See also the <function>settype</function> function.
  </para>

  <para>
   A <type>bool</type> &true; value is converted to the <type>string</type>
   <literal>"1"</literal>. <type>bool</type> &false; is converted to
   <literal>""</literal> (the empty string). This allows conversion back and
   forth between <type>bool</type> and <type>string</type> values.
  </para>

  <para>
   An <type>int</type> or <type>float</type> is converted to a
   <type>string</type> representing the number textually (including the
   exponent part for <type>float</type>s). Floating point numbers can be
   converted using exponential notation (<literal>4.1E+6</literal>).
  </para>

  <note>
   <para>
    As of PHP 8.0.0, the decimal point character is always
    <literal>.</literal>. Prior to PHP 8.0.0,
    the decimal point character is defined in the script's locale (category
    LC_NUMERIC). See the <function>setlocale</function> function.
   </para>
  </note>

  <para>
   <type>Array</type>s are always converted to the <type>string</type>
   <literal>"Array"</literal>; because of this, <function>echo</function> and
   <function>print</function> can not by themselves show the contents of an
   <type>array</type>. To view a single element, use a construction such as
   <literal>echo $arr['foo']</literal>. See below for tips on viewing the entire
   contents.
  </para>

  <para>
   In order to convert <type>object</type>s to <type>string</type> magic
   method <link linkend="language.oop5.magic">__toString</link> must be used.
  </para>

  <para>
   <type>Resource</type>s are always converted to <type>string</type>s with the
   structure <literal>"Resource id #1"</literal>, where <literal>1</literal>
   is the resource number assigned to the <type>resource</type> by PHP at
   runtime. While the exact structure of this string should not be relied on
   and is subject to change, it will always be unique for a given resource
   within the lifetime of a script being executed (ie a Web request or CLI
   process) and won't be reused. To get a <type>resource</type>'s type, use
   the <function>get_resource_type</function> function.
  </para>

  <para>
   &null; is always converted to an empty string.
  </para>

  <para>
   As stated above, directly converting an <type>array</type>,
   <type>object</type>, or <type>resource</type> to a <type>string</type> does
   not provide any useful information about the value beyond its type. See the
   functions <function>print_r</function> and <function>var_dump</function> for
   more effective means of inspecting the contents of these types.
  </para>

  <para>
   Most PHP values can also be converted to <type>string</type>s for permanent
   storage. This method is called serialization, and is performed by the
   <function>serialize</function> function.
  </para>

 </sect2>

 <sect2 xml:id="language.types.string.details">

  <title>Details of the String Type</title>

  <para>
   The <type>string</type> in PHP is implemented as an array of bytes and an
   integer indicating the length of the buffer. It has no information about how
   those bytes translate to characters, leaving that task to the programmer.
   There are no limitations on the values the string can be composed of; in
   particular, bytes with value <literal>0</literal> (“NUL bytes”) are allowed
   anywhere in the string (however, a few functions, said in this manual not to
   be “binary safe”, may hand off the strings to libraries that ignore data
   after a NUL byte.)
  </para>
  <para>
   This nature of the string type explains why there is no separate “byte” type
   in PHP – strings take this role. Functions that return no textual data – for
   instance, arbitrary data read from a network socket – will still return
   strings.
  </para>
  <para>
   Given that PHP does not dictate a specific encoding for strings, one might
   wonder how string literals are encoded. For instance, is the string
   <literal>"á"</literal> equivalent to <literal>"\xE1"</literal> (ISO-8859-1),
   <literal>"\xC3\xA1"</literal> (UTF-8, C form),
   <literal>"\x61\xCC\x81"</literal> (UTF-8, D form) or any other possible
   representation? The answer is that string will be encoded in whatever fashion
   it is encoded in the script file. Thus, if the script is written in
   ISO-8859-1, the string will be encoded in ISO-8859-1 and so on. However,
   this does not apply if Zend Multibyte is enabled; in that case, the script
   may be written in an arbitrary encoding (which is explicitly declared or is
   detected) and then converted to a certain internal encoding, which is then
   the encoding that will be used for the string literals.
   Note that there are some constraints on the encoding of the script (or on the
   internal encoding, should Zend Multibyte be enabled) – this almost always
   means that this encoding should be a compatible superset of ASCII, such as
   UTF-8 or ISO-8859-1. Note, however, that state-dependent encodings where
   the same byte values can be used in initial and non-initial shift states
   may be problematic.
  </para>
  <para>
   Of course, in order to be useful, functions that operate on text may have to
   make some assumptions about how the string is encoded. Unfortunately, there
   is much variation on this matter throughout PHP’s functions:
  </para>
  <itemizedlist>
   <listitem>
    <simpara>
     Some functions assume that the string is encoded in some (any) single-byte
     encoding, but they do not need to interpret those bytes as specific
     characters. This is case of, for instance, <function>substr</function>,
     <function>strpos</function>, <function>strlen</function> or
     <function>strcmp</function>. Another way to think of these functions is
     that operate on memory buffers, i.e., they work with bytes and byte
     offsets.
    </simpara>
   </listitem>
   <listitem>
    <simpara>
     Other functions are passed the encoding of the string, possibly they also
     assume a default if no such information is given. This is the case of
     <function>htmlentities</function> and the majority of the
     functions in the <link linkend="book.mbstring">mbstring</link> extension.
    </simpara>
   </listitem>
   <listitem>
    <simpara>
     Others use the current locale (see <function>setlocale</function>), but
     operate byte-by-byte. This is the case of <function>strcasecmp</function>,
     <function>strtoupper</function> and <function>ucfirst</function>.
     This means they can be used only with single-byte encodings, as long as
     the encoding is matched by the locale. For instance
     <literal>strtoupper("á")</literal> may return <literal>"Á"</literal> if the
     locale is correctly set and <literal>á</literal> is encoded with a single
     byte. If it is encoded in UTF-8, the correct result will not be returned
     and the resulting string may or may not be returned corrupted, depending
     on the current locale.
    </simpara>
   </listitem>
   <listitem>
    <simpara>
     Finally, they may just assume the string is using a specific encoding,
     usually UTF-8. This is the case of most functions in the
     <link linkend="book.intl">intl</link> extension and in the
     <link linkend="book.pcre">PCRE</link> extension
     (in the last case, only when the <literal>u</literal> modifier is used).
     Although this is due to their special purpose, the function
     <function>utf8_decode</function> assumes a UTF-8 encoding and the
     function <function>utf8_encode</function> assumes an ISO-8859-1 encoding.
    </simpara>
   </listitem>
  </itemizedlist>

  <para>
   Ultimately, this means writing correct programs using Unicode depends on
   carefully avoiding functions that will not work and that most likely will
   corrupt the data and using instead the functions that do behave correctly,
   generally from the <link linkend="book.intl">intl</link> and
   <link linkend="book.mbstring">mbstring</link> extensions.
   However, using functions that can handle Unicode encodings is just the
   beginning. No matter the functions the language provides, it is essential to
   know the Unicode specification. For instance, a program that assumes there is
   only uppercase and lowercase is making a wrong assumption.
  </para>
 </sect2>
</sect1><!-- end string -->

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
