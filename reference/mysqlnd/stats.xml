<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: 40667918dcff1d5c9f7ecdc88b5caca24ba0686c Maintainer: samesch Status: ready -->
<!-- Reviewed: no -->
<chapter xml:id="mysqlnd.stats" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
 <title>Statistiken</title>
 <para>
  <emphasis role="bold">Verwendung statistischer Daten</emphasis>
 </para>
 <para>
  Der MySQL Native Driver bietet die Möglichkeit, Statistiken über die
  Kommunikation zwischen Client und Server zu sammeln. Es gibt zwei Arten von
  Statistiken:
 </para>
 <itemizedlist>
  <listitem>
   <para>
    Client-Statistiken
   </para>
  </listitem>
  <listitem>
   <para>
    Verbindungsstatistiken
   </para>
  </listitem>
 </itemizedlist>
 <para>
  Wenn die Erweiterung <literal>mysqli</literal> verwendet wird, können diese
  Statistiken über zwei API-Aufrufe abgerufen werden:
 </para>
 <itemizedlist>
  <listitem>
   <para>
    <function>mysqli_get_client_stats</function>
   </para>
  </listitem>
  <listitem>
   <para>
    <function>mysqli_get_connection_stats</function>
   </para>
  </listitem>
 </itemizedlist>
 <note>
  <para>
   Die Statistiken werden für alle Erweiterungen zusammengefasst, die den
   MySQL Native Driver verwenden. Wenn zum Beispiel sowohl
   <literal>ext/mysql</literal> als auch <literal>ext/mysqli</literal> mit dem
   MySQL Native Driver kompiliert werden, verändern sowohl die
   Funktionsaufrufe von <literal>ext/mysql</literal> als auch von
   <literal>ext/mysqli</literal> die Statistiken. Es gibt keine Möglichkeit,
   herauszufinden, wie sehr ein bestimmter API-Aufruf einer Erweiterung, die
   gegen den MySQL Native Driver kompiliert wurde, eine bestimmte Statistik
   beeinflusst hat. Der MySQL PDO Driver, <literal>ext/mysql</literal> und
   <literal>ext/mysqli</literal> können so konfiguriert werden, dass sie
   optional den MySQL Native Driver verwenden. In diesem Fall werden die
   Statistiken von allen drei Erweiterungen verändert.
  </para>
 </note>
 <para>
  <emphasis role="bold">Client-Statistiken abrufen</emphasis>
 </para>
 <para>
  Auf die Client-Statistiken kann mit der Funktion
  <function>mysqli_get_client_stats</function> zugegriffen werden. Für den
  Funktionsaufruf werden keine Parameter benötigt.
 </para>
 <para>
  Die Funktion gibt ein assoziatives Array zurück, das die Namen der
  Statistiken als Schlüssel und die statistischen Daten als Werte enthält.
 </para>
 <para>
  Auf die Client-Statistiken kann auch mit der Funktion
  <function>phpinfo</function> zugegriffen werden.
 </para>
 <para>
  <emphasis role="bold">Verbindungsstatistiken abrufen</emphasis>
 </para>
 <para>
  Auf die Verbindungstatistiken kann mit der Funktion
  <function>mysqli_get_connection_stats</function> zugegriffen werden. Für den
  Funktionsaufruf werden keine Parameter benötigt.
 </para>
 <para>
  Die Funktion gibt ein assoziatives Array zurück, das die Namen der
  Statistiken als Schlüssel und die statistischen Daten als Werte enthält.
 </para>
 <para>
  <emphasis role="bold">Gepufferte und ungepufferte Ergebnismengen</emphasis>
 </para>
 <para>
  Ergebnismengen können gepuffert oder ungepuffert sein. Mit den
  Standardeinstellungen arbeiten <literal>ext/mysql</literal> und
  <literal>ext/mysqli</literal> bei normalen Abfragen (ohne vorbereitete
  Anweisungen) mit gepufferten Ergebnismengen. Gepufferte Ergebnismengen
  werden auf dem Client zwischengespeichert. Nach der Ausführung der Abfrage
  werden alle Ergebnisse vom MySQL-Server abgerufen und in einem
  Zwischenspeicher auf dem Client abgelegt. Der große Vorteil von gepufferten
  Ergebnismengen besteht darin, dass der Server alle einer Ergebnismenge
  zugewiesenen Ressourcen freigeben kann, nachdem die Ergebnisse durch den
  Client abgerufen wurden.
 </para>
 <para>
  Im Gegensatz dazu werden ungepufferte Ergebnismengen viel länger auf dem
  Server gehalten. Wenn der Speicherbedarf auf dem Client reduziert werden
  soll und dafür eine höhere Last auf dem Server in Kauf genommen werden kann,
  sollten ungepufferte Ergebnisse verwendet werden. Wenn die Serverlast hoch
  ist und die Werte für ungepufferte Ergebnismengen hoch sind, sollte in
  Betracht gezogen werden, die Last auf die Clients zu verlagern. Clients sind
  in der Regel besser skalierbar als Server. <quote>Last</quote> bezieht sich
  nicht nur auf Speicherpuffer - der Server muss auch andere Ressourcen offen
  halten, &zb; Datei-Deskriptoren und Threads, bevor eine Ergebnismenge
  freigegeben werden kann.
 </para>
 <para>
  Vorbereitete Anweisungen (Prepared Statements) verwenden standardmäßig
  ungepufferte Ergebnismengen. Mit der Funktion
  <function>mysqli_stmt_store_result</function> kann aber bei Bedarf die
  Pufferung von Ergebnismengen aktiviert werden.
 </para>
 <para>
  <emphasis role="bold">Vom MySQL Native Driver zurückgegebene Statistiken</emphasis>
 </para>
 <para>
  Die folgenden Tabellen enthalten eine Liste von Statistiken, die von den
  Funktionen <function>mysqli_get_client_stats</function> und
  <function>mysqli_get_connection_stats</function> zurückgegeben werden.
 </para>
 <table xml:id="mysqlnd.stats.returns">
  <title>Von mysqlnd zurückgegebene Statistiken: Netzwerk</title>
  <tgroup cols="4">
   <colspec colwidth="10*"/>
   <colspec colwidth="10*"/>
   <colspec colwidth="40*"/>
   <colspec colwidth="40*"/>
   <thead>
    <row>
     <entry>Statistik</entry>
     <entry>Bereich</entry>
     <entry>&Description;</entry>
     <entry>Hinweise</entry>
    </row>
   </thead>
   <tbody>
    <row>
     <entry><literal>bytes_sent</literal></entry>
     <entry>Verbindung</entry>
     <entry>Die Anzahl der von PHP an den MySQL-Server gesendeten Bytes</entry>
     <entry>Kann verwendet werden, um die Effizienz des
      Komprimierungsprotokolls zu überprüfen</entry>
    </row>
    <row>
     <entry><literal>bytes_received</literal></entry>
     <entry>Verbindung</entry>
     <entry>Die Anzahl der vom MySQL-Server empfangenen Bytes</entry>
     <entry>Kann verwendet werden, um die Effizienz des
      Komprimierungsprotokolls zu überprüfen</entry>
    </row>
    <row>
     <entry><literal>packets_sent</literal></entry>
     <entry>Verbindung</entry>
     <entry>Die Anzahl der gesendeten MySQL-Client-Server-Protokollpakete</entry>
     <entry>Wird zur Fehlersuche in der Implementierung des
      Client-Server-Protokolls verwendet</entry>
    </row>
    <row>
     <entry><literal>packets_received</literal></entry>
     <entry>Verbindung</entry>
     <entry>Die Anzahl der empfangenen MySQL-Client-Server-Protokollpakete</entry>
     <entry>Wird zur Fehlersuche in der Implementierung des
      Client-Server-Protokolls verwendet</entry>
    </row>
    <row>
     <entry><literal>protocol_overhead_in</literal></entry>
     <entry>Verbindung</entry>
     <entry>Der Overhead des MySQL-Client-Server-Protokolls für eingehenden
      Datenverkehr in Bytes. Derzeit wird nur der Paket-Header (4 Bytes) als
      Overhead betrachtet. protocol_overhead_in = packets_received * 4</entry>
     <entry>Wird zur Fehlersuche in der Implementierung des
      Client-Server-Protokolls verwendet</entry>
    </row>
    <row>
     <entry><literal>protocol_overhead_out</literal></entry>
     <entry>Verbindung</entry>
     <entry>Der Overhead des MySQL-Client-Server-Protokolls für ausgehenden
      Datenverkehr in Bytes. Derzeit wird nur der Paket-Header (4 Bytes) als
      Overheadbetrachtet. protocol_overhead_in = packets_received * 4</entry>
     <entry>Wird zur Fehlersuche in der Implementierung des
      Client-Server-Protokolls verwendet</entry>
    </row>
    <row>
     <entry><literal>bytes_received_ok_packet</literal></entry>
     <entry>Verbindung</entry>
     <entry>Die Gesamtgröße der mit dem MySQL-Client-Server-Protokoll
      empfangenen OK-Pakete in Bytes. Die OK-Pakete können eine Statusmeldung
      enthalten, deren Länge variieren kann, weshalb die Größe eines OK-Pakets
      nicht festgelegt ist.</entry>
     <entry>Wird zur Fehlersuche in der Implementierung des CS-Protokolls
      verwendet. Es ist zu beachten, dass in der Gesamtgröße in Bytes die
      Größe des Header-Pakets enthalten ist (4 Bytes, siehe
      Protokoll-Overhead).</entry>
    </row>
    <row>
     <entry><literal>packets_received_ok</literal></entry>
     <entry>Verbindung</entry>
     <entry>Die Anzahl der mit dem MySQL-Client-Server-Protokoll empfangenen
      OK-Pakete</entry>
     <entry>Wird zur Fehlersuche in der Implementierung des CS-Protokolls
      verwendet. Es ist zu beachten, dass in der Gesamtgröße in Bytes die
      Größe des Header-Pakets enthalten ist (4 Bytes, siehe
      Protokoll-Overhead).</entry>
    </row>
    <row>
     <entry><literal>bytes_received_eof_packet</literal></entry>
     <entry>Verbindung</entry>
     <entry>Die Gesamtgröße der mit dem MySQL-Client-Server-Protokoll
      empfangenen EOF-Pakete in Bytes. Die Größe von EOF kann je nach
      Serverversion variieren. Außerdem kann EOF eine Fehlermeldung
      enthalten.</entry>
     <entry>Wird zur Fehlersuche in der Implementierung des CS-Protokolls
      verwendet. Es ist zu beachten, dass in der Gesamtgröße in Bytes die
      Größe des Header-Pakets enthalten ist (4 Bytes, siehe
      Protokoll-Overhead).</entry>
    </row>
    <row>
     <entry><literal>packets_received_eof</literal></entry>
     <entry>Verbindung</entry>
     <entry>Die Anzahl der mit dem MySQL-Client-Server-Protokoll empfangenen
      EOF-Pakete. Wie bei anderen Paketstatistiken erhöht sich die Anzahl der
      Pakete auch dann, wenn PHP nicht das erwartete Paket, sondern &zb; eine
      Fehlermeldung empfängt.</entry>
     <entry>Wird zur Fehlersuche in der Implementierung des CS-Protokolls
      verwendet. Es ist zu beachten, dass in der Gesamtgröße in Bytes die
      Größe des Header-Pakets enthalten ist (4 Bytes, siehe
      Protokoll-Overhead).</entry>
    </row>
    <row>
     <entry><literal>bytes_received_rset_header_packet</literal></entry>
     <entry>Verbindung</entry>
     <entry>Die Gesamtgröße der mit dem MySQL-Client-Server-Protokoll
      empfangenen Header-Pakete der Ergebnismenge in Bytes. Die Größe der
      Pakete variiert in Abhängigkeit von der Nutzlast
      (<literal>LOAD LOCAL INFILE</literal>, <literal>INSERT</literal>,
      <literal>UPDATE</literal>, <literal>SELECT</literal>,
      Fehlermeldung).</entry>
     <entry>Wird zur Fehlersuche in der Implementierung des CS-Protokolls
      verwendet. Es ist zu beachten, dass in der Gesamtgröße in Bytes die
      Größe des Header-Pakets enthalten ist (4 Bytes, siehe
      Protokoll-Overhead).</entry>
    </row>
    <row>
     <entry><literal>packets_received_rset_header</literal></entry>
     <entry>Verbindung</entry>
     <entry>Die Anzahl der mit dem MySQL-Client-Server-Protokoll empfangenen
      Header-Pakete der Ergebnismenge</entry>
     <entry>Wird zur Fehlersuche in der Implementierung des CS-Protokolls
      verwendet. Es ist zu beachten, dass in der Gesamtgröße in Bytes die
      Größe des Header-Pakets enthalten ist (4 Bytes, siehe
      Protokoll-Overhead).</entry>
    </row>
    <row>
     <entry><literal>bytes_received_rset_field_meta_packet</literal></entry>
     <entry>Verbindung</entry>
     <entry>Die Gesamtgröße der mit dem MySQL-Client-Server-Protokoll
      empfangenen Metadaten-Pakete (Spalteninformationen) der Ergebnismenge in
      Bytes. Die Größe hängt natürlich von den Feldern in der Ergebnismenge
      ab. Im Fall von COM_LIST_FIELDS kann das Paket auch eine Fehlermeldung
      oder ein EOF-Paket enthalten.</entry>
     <entry>Nur nützlich für die Fehlersuche in der Implementierung des
      CS-Protokolls. Es ist zu beachten, dass in der Gesamtgröße in Bytes die
      Größe des Header-Pakets enthalten ist (4 Bytes, siehe
      Protokoll-Overhead).</entry>
    </row>
    <row>
     <entry><literal>packets_received_rset_field_meta</literal></entry>
     <entry>Verbindung</entry>
     <entry>Die Anzahl der mit dem MySQL-Client-Server-Protokoll empfangenen
      Metadaten-Pakete (Spalteninformationen) der Ergebnismenge</entry>
     <entry>Nur nützlich für die Fehlersuche in der Implementierung des
      CS-Protokolls. Es ist zu beachten, dass in der Gesamtgröße in Bytes die
      Größe des Header-Pakets enthalten ist (4 Bytes, siehe
      Protokoll-Overhead).</entry>
    </row>
    <row>
     <entry><literal>bytes_received_rset_row_packet</literal></entry>
     <entry>Verbindung</entry>
     <entry>Die Gesamtgröße der mit dem MySQL-Client-Server-Protokoll
      empfangenen Pakete mit den Zeilendaten der Ergebnismenge in Bytes. Das
      Paket kann auch eine Fehlermeldung oder ein EOF-Paket enthalten. Die
      Anzahl der Fehlermeldungen und EOF-Pakete können ermittelt werden, indem
      <literal>rows_fetched_from_server_normal</literal> und
      <literal>rows_fetched_from_server_ps</literal> von
      <literal>bytes_received_rset_row_packet</literal> abgezogen
      werden.</entry>
     <entry>Nur nützlich für die Fehlersuche in der Implementierung des
      CS-Protokolls. Es ist zu beachten, dass in der Gesamtgröße in Bytes die
      Größe des Header-Pakets enthalten ist (4 Bytes, siehe
      Protokoll-Overhead).</entry>
    </row>
    <row>
     <entry><literal>packets_received_rset_row</literal></entry>
     <entry>Verbindung</entry>
     <entry>Die Anzahl der mit dem MySQL-Client-Server-Protokoll empfangenen
      Pakete mit den Zeilendaten der Ergebnismenge und deren Gesamtgröße in
      Bytes</entry>
     <entry>Nur nützlich für die Fehlersuche in der Implementierung des
      CS-Protokolls. Es ist zu beachten, dass in der Gesamtgröße in Bytes die
      Größe des Header-Pakets enthalten ist (4 Bytes, siehe
      Protokoll-Overhead).</entry>
    </row>
    <row>
     <entry><literal>bytes_received_prepare_response_packet</literal></entry>
     <entry>Verbindung</entry>
     <entry>Die Gesamtgröße der Pakete für die Initialisierung vorbereiteter
      Anweisungen (prepared statement init packets), die vom
      MySQL-Client-Server-Protokoll als OK zurückgegeben werden, in Bytes.
      Diese Pakete können auch Fehlermeldungen enthalten. Die Größe der Pakete
      hängt von der MySQL-Version ab: 9 Bytes bei MySQL 4.1 und 12 Bytes ab
      MySQL 5.0. Es gibt keine zuverlässige Möglichkeit, die Anzahl der
      aufgetreten Fehler zu ermitteln. Eventuell lässt sich erraten, dass ein
      Fehler aufgetreten ist, wenn man sich &zb; immer mit MySQL 5.0 oder
      neuer verbindet und
      <literal>bytes_received_prepare_response_packet</literal> !=
      <literal>packets_received_prepare_response</literal> * 12. Siehe auch
      <literal>ps_prepared_never_executed</literal>,
      <literal>ps_prepared_once_executed</literal>.</entry>
     <entry>Nur nützlich für die Fehlersuche in der Implementierung des
      CS-Protokolls. Es ist zu beachten, dass in der Gesamtgröße in Bytes die
      Größe des Header-Pakets enthalten ist (4 Bytes, siehe
      Protokoll-Overhead).</entry>
    </row>
    <row>
     <entry><literal>packets_received_prepare_response</literal></entry>
     <entry>Verbindung</entry>
     <entry>Die Anzahl der Pakete für die Initialisierung vorbereiteter
      Anweisungen (prepared statement init packets), die vom
      MySQL-Client-Server-Protokoll als OK zurückgegeben werden.</entry>
     <entry>Nur nützlich für die Fehlersuche in der Implementierung des
      CS-Protokolls. Es ist zu beachten, dass in der Gesamtgröße in Bytes die
      Größe des Header-Pakets enthalten ist (4 Bytes, siehe
      Protokoll-Overhead).</entry>
    </row>
    <row>
     <entry><literal>bytes_received_change_user_packet</literal></entry>
     <entry>Verbindung</entry>
     <entry>Die Gesamtgröße der mit dem MySQL-Client-Server-Protokoll
      empfangenen COM_CHANGE_USER-Pakete in Bytes. Ein Paket kann auch eine
      Fehlermeldung oder ein EOF enthalten.</entry>
     <entry>Nur nützlich für die Fehlersuche in der Implementierung des
      CS-Protokolls. Es ist zu beachten, dass in der Gesamtgröße in Bytes die
      Größe des Header-Pakets enthalten ist (4 Bytes, siehe
      Protokoll-Overhead).</entry>
    </row>
    <row>
     <entry><literal>packets_received_change_user</literal></entry>
     <entry>Verbindung</entry>
     <entry>Die Anzahl der mit dem MySQL-Client-Server-Protokoll empfangenen
      COM_CHANGE_USER-Pakete</entry>
     <entry>Nur nützlich für die Fehlersuche in der Implementierung des
      CS-Protokolls. Es ist zu beachten, dass in der Gesamtgröße in Bytes die
      Größe des Header-Pakets enthalten ist (4 Bytes, siehe
      Protokoll-Overhead).</entry>
    </row>
    <row>
     <entry><literal>packets_sent_command</literal></entry>
     <entry>Verbindung</entry>
     <entry>Die Anzahl der Befehle des MySQL-Client-Server-Protokolls, die von
      PHP an MySQL gesendet wurden. Es gibt keine Möglichkeit herauszufinden,
      welche spezifischen Befehle gesendet wurden und wie viele davon.
      Bestenfalls kann damit überprüft werden, ob PHP Befehle an MySQL
      gesendet hat, um festzustellen, ob die Unterstützung von MySQL in der
      PHP-Binärdatei deaktiviert werden kann. Es gibt auch keine Möglichkeit,
      die Anzahl der Fehler zu ermitteln, die beim Senden von Daten an MySQL
      aufgetreten sind. Der einzige Fehler, der aufgezeichnet wird, ist
      command_buffer_too_small (siehe unten).</entry>
     <entry>Nur nützlich für die Fehlersuche in der Implementierung des
      CS-Protokolls.</entry>
    </row>
    <row>
     <entry><literal>bytes_received_real_data_normal</literal></entry>
     <entry>Verbindung</entry>
     <entry>Die Anzahl der Bytes an Nutzdaten, die der PHP-Client über das
      Textprotokoll von <literal>mysqlnd</literal> abgerufen hat.</entry>
     <entry>Dies ist die Größe der tatsächlichen Daten, die in den
      Ergebnismengen enthalten sind, die vom PHP-Client abgerufen wurden und
      nicht aus vorbereiteten Anweisungen stammen. Zu beachten ist, dass,
      obwohl eine vollständige Ergebnismenge von <literal>mysqlnd</literal>
      aus MySQL abgerufen wurde, diese Statistik nur die tatsächlichen Daten
      zählt, die vom PHP-Client aus <literal>mysqlnd</literal> abgerufen
      wurden. Ein Beispiel für eine Codesequenz, die den Wert erhöht, lautet
      wie folgt:
      <programlisting>
<![CDATA[
$mysqli = new mysqli();
$res = $mysqli->query("SELECT 'abc'");
$res->fetch_assoc();
$res->close();
]]>
      </programlisting>
      <para>
       Jeder Abrufvorgang erhöht den Wert.
      </para>

      <para>
       Die Statistik wird nicht erhöht, wenn die Ergebnismenge auf dem Client
       nur gepuffert, aber nicht abgerufen wird, wie im folgenden Beispiel:
      </para>
      <programlisting>
<![CDATA[
$mysqli = new mysqli();
$res = $mysqli->query("SELECT 'abc'");
$res->close();
]]>
      </programlisting>
     </entry>
    </row>
    <row>
     <entry><literal>bytes_received_real_data_ps</literal></entry>
     <entry>Verbindung</entry>
     <entry>Die Anzahl der Bytes an Nutzdaten, die der PHP-Client über das
      Protokoll für vorbereitete Anweisungen von <literal>mysqlnd</literal>
      abgerufen hat.</entry>
     <entry>Dies ist die Größe der tatsächlichen Daten, die in den
      Ergebnismengen enthalten sind, die vom PHP-Client abgerufen wurden und
      aus vorbereiteten Anweisungen stammen. Der Wert erhöht sich nur dann,
      wenn die Ergebnismenge anschließend vom PHP-Client gelesen wird. Zu
      beachten ist, dass, obwohl eine vollständige Ergebnismenge von
      <literal>mysqlnd</literal> aus MySQL abgerufen wurde, diese Statistik
      nur die tatsächlichen Daten zählt, die vom PHP-Client aus
      <literal>mysqlnd</literal> abgerufen wurden. Siehe auch
      <literal>bytes_received_real_data_normal</literal>.</entry>
    </row>
   </tbody>
  </tgroup>
 </table>
 <para>
  <emphasis role="bold">Ergebnismenge</emphasis>
 </para>
 <table xml:id="mysqlnd.stats.results">
  <title>Von mysqlnd zurückgegebene Statistiken: Ergebnismenge</title>
  <tgroup cols="4">
   <colspec colwidth="10*"/>
   <colspec colwidth="10*"/>
   <colspec colwidth="40*"/>
   <colspec colwidth="40*"/>
   <thead>
    <row>
     <entry>Statistik</entry>
     <entry>Bereich</entry>
     <entry>&Description;</entry>
     <entry>Hinweise</entry>
    </row>
   </thead>
   <tbody>
    <row>
     <entry><literal>result_set_queries</literal></entry>
     <entry>Verbindung</entry>
     <entry>Die Anzahl der Abfragen, die eine Ergebnismenge erzeugt haben.
      Beispiele für Abfragen, die eine Ergebnismenge erzeugen:
      <literal>SELECT</literal>, <literal>SHOW</literal>. Die Statistik wird
      nicht erhöht, wenn beim Lesen des Header-Pakets einer Zeile der
      Ergebnismenge ein Fehler aufgetreten ist.</entry>
     <entry>Dieser Wert kann als indirektes Maß für die Anzahl der von PHP an
      MySQL gesendeten Anfragen verwendet werden, um &zb; einen Client zu
      identifizieren, der eine hohe Datenbanklast verursacht.</entry>
    </row>
    <row>
     <entry><literal>non_result_set_queries</literal></entry>
     <entry>Verbindung</entry>
     <entry>Die Anzahl der Abfragen, die keine Ergebnismenge erzeugt haben.
      Beispiele für Abfragen, die keine Ergebnismenge erzeugen:
      <literal>INSERT</literal>, <literal>UPDATE</literal>, <literal>LOAD
      DATA</literal>. Die Statistik wird nicht erhöht, wenn beim Lesen des
      Header-Pakets einer Zeile der Ergebnismenge ein Fehler aufgetreten
      ist.</entry>
     <entry>Dieser Wert kann als indirektes Maß für die Anzahl der von PHP an
      MySQL gesendeten Anfragen verwendet werden, um &zb; einen Client zu
      identifizieren, der eine hohe Datenbanklast verursacht.</entry>
    </row>
    <row>
     <entry><literal>no_index_used</literal></entry>
     <entry>Verbindung</entry>
     <entry>Die Anzahl der Abfragen, die eine Ergebnismenge erzeugt, aber
      keinen Index verwendet haben (siehe auch die mysqld-Startoption
      –log-queries-not-using-indexes).</entry>
     <entry>Wenn diese Anfragen gemeldet werden sollen, muss
      mysqli_report(MYSQLI_REPORT_INDEX) verwendet werden, damit ext/mysqli
      eine Exception auslöst. Wenn eine Warnung anstelle einer Exception
      benötigt wird, muss mysqli_report(MYSQLI_REPORT_INDEX ^
      MYSQLI_REPORT_STRICT) verwendet werden.</entry>
     <entry></entry>
    </row>
    <row>
     <entry><literal>bad_index_used</literal></entry>
     <entry>Verbindung</entry>
     <entry>Die Anzahl der Abfragen, die eine Ergebnismenge erzeugt, aber
      keinen guten Index verwendet haben (siehe auch die mysqld-Startoption
      –log-slow-queries).</entry>
     <entry>Wenn diese Anfragen gemeldet werden sollen, muss
      mysqli_report(MYSQLI_REPORT_INDEX) verwendet werden, damit ext/mysqli
      eine Exception auslöst. Wenn eine Warnung anstelle einer Exception
      benötigt wird, muss mysqli_report(MYSQLI_REPORT_INDEX ^
      MYSQLI_REPORT_STRICT) verwendet werden.</entry>
    </row>
    <row>
     <entry><literal>slow_queries</literal></entry>
     <entry>Verbindung</entry>
     <entry>SQL-Anweisungen, deren Ausführung länger als
      <literal>long_query_time</literal> Sekunden dauerte und bei denen
      mindestens <literal>min_examined_row_limit</literal> Zeilen untersucht
      werden mussten.</entry>
     <entry>Wird von <function>mysqli_report</function> nicht gemeldet</entry>
    </row>
    <row>
     <entry><literal>buffered_sets</literal></entry>
     <entry>Verbindung</entry>
     <entry>Die Anzahl der gepufferten Ergebnismengen, die von
      <quote>normalen</quote> Abfragen zurückgegeben wurden.
      <quote>Normal</quote> bedeutet <quote>ohne vorbereitete
      Anweisung</quote> im Sinne der folgenden Hinweise.</entry>
     <entry>Beispiele für API-Aufrufe, die Ergebnismengen auf dem Client
      puffern: <function>mysql_query</function>,
      <function>mysqli_query</function>,
      <function>mysqli_store_result</function>,
      <function>mysqli_stmt_get_result</function>. Durch das
      Zwischenspreichern der Ergebnismengen auf dem Client wird sichergestellt,
      dass die Ressourcen des Servers so schnell wie möglich freigegeben
      werden. Außerdem ist es einfacher, die Ergebnismengen zu durchsuchen.
      Der Nachteil ist der zusätzliche Speicherbedarf des Clients für die
      Pufferung der Daten. Es ist zu beachten, dass mysqlnd (im Gegensatz zur
      MySQL Client Library) das PHP-Speicherlimit einhält, weil es PHP-interne
      Speicherverwaltungsfunktionen verwendet, um Speicher zuzuweisen. Das ist
      auch der Grund, warum <function>memory_get_usage</function> einen
      höheren Speicherverbrauch meldet, wenn mysqlnd anstelle der MySQL Client
      Library verwendet wird. Der Speicherbedarf der MySQL Client Library wird
      von <function>memory_get_usage</function> überhaupt nicht gemessen, weil
      die MySQL Client Library keine von der Funktion überwachten PHP-internen
      Speicherverwaltungsfunktionen verwendet!</entry>
    </row>
    <row>
     <entry><literal>unbuffered_sets</literal></entry>
     <entry>Verbindung</entry>
     <entry>Die Anzahl der ungepufferten Ergebnismengen, die von normalen
      Abfragen (ohne vorbereitete Anweisung) zurückgegeben wurden.</entry>
     <entry>Ein Beispiel für API-Aufrufe, die keine Ergebnismengen auf dem
      Client puffern: <function>mysqli_use_result</function></entry>
    </row>
    <row>
     <entry><literal>ps_buffered_sets</literal></entry>
     <entry>Verbindung</entry>
     <entry>Die Anzahl der gepufferten Ergebnismengen, die von vorbereiteten
      Anweisungen zurückgegeben wurden. In der Standardeinstellung
      werden vorbereitete Anweisungen nicht gepuffert.</entry>
     <entry>Ein Beispiel für API-Aufrufe, die Ergebnismengen auf dem Client
      puffern: <literal>mysqli_stmt_store_result</literal></entry>
    </row>
    <row>
     <entry><literal>ps_unbuffered_sets</literal></entry>
     <entry>Verbindung</entry>
     <entry>Die Anzahl der ungepufferten Ergebnismengen, die von vorbereiteten
      Anweisungen zurückgegeben wurden.</entry>
     <entry>In der Standardeinstellung werden vorbereitete Anweisungen nicht
      gepuffert.</entry>
    </row>
    <row>
     <entry><literal>flushed_normal_sets</literal></entry>
     <entry>Verbindung</entry>
     <entry>Die Anzahl der Ergebnismengen normaler Abfragen (ohne vorbereitete
      Anweisung) mit ungelesenen Daten, die stillschweigend geleert wurden.
      Die Bereinigung (Flushing) erfolgt nur bei ungepufferten
      Ergebnismengen.</entry>
     <entry>Ungepufferte Ergebnismengen müssen vollständig abgerufen werden,
      bevor eine neue Abfrage über die Verbindung ausgeführt werden kann,
      sonst gibt MySQL einen Fehler aus. Wenn eine Anwendung nicht alle Zeilen
      aus einer ungepufferten Ergebnismenge abruft, ruft mysqlnd die
      Ergebnismenge implizit ab, um die die Verbindung freizugeben. Siehe auch
      <literal>rows_skipped_normal</literal>,
      <literal>rows_skipped_ps</literal>. Ein paar mögliche Ursachen für einen
      impliziten Flush:
      <itemizedlist>
       <listitem>
        <para>
         Eine fehlerhafte Client-Anwendung
        </para>
       </listitem>
       <listitem>
        <para>
         Der Client hat aufgehört, Zeilen abzurufen, weil er gefunden hat,
         wonach er gesucht hat, aber die Ergebnismenge wurde noch nicht
         vollständig abgerufen
        </para>
       </listitem>
       <listitem>
        <para>
         Die Client-Anwendung wurde unerwartet beendet
        </para>
       </listitem>
      </itemizedlist></entry>
    </row>
    <row>
     <entry><literal>flushed_ps_sets</literal></entry>
     <entry>Verbindung</entry>
     <entry>Die Anzahl der Ergebnismengen vorbereiteter Anweisungen mit
      ungelesenen Daten, die stillschweigend geleert wurden. Die Bereinigung
      (Flushing) erfolgt nur bei ungepufferten Ergebnismengen.</entry>
     <entry>Ungepufferte Ergebnismengen müssen vollständig abgerufen werden,
      bevor eine neue Abfrage über die Verbindung ausgeführt werden kann,
      sonst gibt MySQL einen Fehler aus. Wenn eine Anwendung nicht alle Zeilen
      aus einer ungepufferten Ergebnismenge abruft, ruft mysqlnd die
      Ergebnismenge implizit ab, um die die Verbindung freizugeben. Siehe auch
      <literal>rows_skipped_normal</literal>,
      <literal>rows_skipped_ps</literal>. Ein paar mögliche Ursachen für einen
      impliziten Flush:
      <itemizedlist>
       <listitem>
        <para>
         Eine fehlerhafte Client-Anwendung
        </para>
       </listitem>
       <listitem>
        <para>
         Der Client hat aufgehört, Zeilen abzurufen, weil er gefunden hat,
         wonach er gesucht hat, aber die Ergebnismenge wurde noch nicht
         vollständig abgerufen
        </para>
       </listitem>
       <listitem>
        <para>
         Die Client-Anwendung wurde unerwartet beendet
        </para>
       </listitem>
      </itemizedlist></entry>
    </row>
    <row>
     <entry><literal>ps_prepared_never_executed</literal></entry>
     <entry>Verbindung</entry>
     <entry>Die Anzahl der vorbereiteten, aber nie ausgeführten Anweisungen</entry>
     <entry>Vorbereitete Anweisungen belegen Server-Ressourcen. Eine Anweisung
      sollte nur dann vorbereitet werden, wenn sie auch ausgeführt werden
      soll.</entry>
    </row>
    <row>
     <entry><literal>ps_prepared_once_executed</literal></entry>
     <entry>Verbindung</entry>
     <entry>Die Anzahl der vorbereiteten Anweisungen, die nur einmal
      ausgeführt wurden</entry>
     <entry>Eine der Ideen hinter vorbereiteten Anweisungen ist, dieselbe
      Abfrage immer wieder auszuführen (mit unterschiedlichen Parametern),
      sodass ein Teil der Syntaxanalyse und anderer Vorbereitungsarbeiten
      eingespart werden kann, wenn die Ausführung der Anweisung in separate
      Vorbereitungs- und Ausführungsphasen aufgeteilt wird. Die Idee ist, eine
      Anweisung einmal vorzubereiten und die Ergebnisse zwischenzuspeichern,
      zu <quote>cachen</quote>, &zb; den Syntaxbaum, der dann bei wiederholter
      Ausführung einer Anweisung wiederverwendet werden kann. Wenn eine
      vorbereitete Anweisung nur einmal ausgeführt wird, kann die zweistufige
      Verarbeitung im Vergleich zu einer <quote>normalen</quote> Abfrage
      ineffizient sein, weil die Zwischenspeicherung zusätzliche Arbeit
      bedeutet und (begrenzte) Server-Ressourcen für die Speicherung der
      zwischengespeicherten Informationen benötigt werden. Folglich können
      vorbereitete Anweisungen, die nur einmal ausgeführt werden, zu
      Leistungseinbußen führen.</entry>
    </row>
    <row>
     <entry><literal>rows_fetched_from_server_normal</literal>,
      <literal>rows_fetched_from_server_ps</literal></entry>
     <entry>Verbindung</entry>
     <entry>Die Anzahl der Zeilen der Ergebnismenge, die erfolgreich von MySQL
      abgerufen wurden, unabhängig davon, ob die Client-Anwendung sie
      verarbeitet hat oder nicht. Einige der Zeilen wurden möglicherweise
      nicht von der Client-Anwendung abgerufen, sondern implizit
      geleert.</entry>
     <entry>Siehe auch <literal>packets_received_rset_row</literal></entry>
    </row>
    <row>
     <entry><literal>rows_buffered_from_client_normal</literal>,
      <literal>rows_buffered_from_client_ps</literal></entry>
     <entry>Verbindung</entry>
     <entry>Die Anzahl der erfolgreich gepufferten Zeilen, die von einer
      "normalen" Abfrage oder einer vorbereiteten Anweisung stammen. Dies ist
      die Anzahl der Zeilen, die von MySQL abgerufen und auf dem Client
      gepuffert wurden. Es ist zu beachten, dass es zwei verschiedene
      Statistiken gibt: über Zeilen, die gepuffert wurden (der interne Puffer
      zwischen MySQL und mysqlnd) und über gepufferte Zeilen, die von der
      Client-Anwendung abgerufen wurden (der interne Puffer zwischen mysqlnd
      und Client-Anwendung). Wenn die Anzahl der gepufferten Zeilen höher ist
      als die Anzahl der abgerufenen gepufferten Zeilen, kann das bedeuten,
      dass die Client-Anwendung Abfragen ausführt, die größere Ergebnismengen
      verursachen als nötig, was zu Zeilen führt, die vom Client nicht gelesen
      werden.</entry>
     <entry>Beispiele für Abfragen, die Ergebnisse puffern:
      <function>mysqli_query</function>,
      <function>mysqli_store_result</function></entry>
    </row>
    <row>
     <entry><literal>rows_fetched_from_client_normal_buffered</literal>,
      <literal>rows_fetched_from_client_ps_buffered</literal></entry>
     <entry>Verbindung</entry>
     <entry>Die Anzahl der Zeilen, die der Client aus einer gepufferten
      Ergebnismenge abgerufen hat, die durch eine "normale" Abfrage oder eine
      vorbereitete Anweisung erstellt wurde.</entry>
     <entry></entry>
    </row>
    <row>
     <entry><literal>rows_fetched_from_client_normal_unbuffered</literal>,
      <literal>rows_fetched_from_client_ps_unbuffered</literal></entry>
     <entry>Verbindung</entry>
     <entry>Die Anzahl der Zeilen, die der Client aus einer ungepufferten
      Ergebnismenge abgerufen hat, die durch eine "normale" Abfrage oder eine
      vorbereitete Anweisung erstellt wurde.</entry>
     <entry></entry>
    </row>
    <row>
     <entry><literal>rows_fetched_from_client_ps_cursor</literal></entry>
     <entry>Verbindung</entry>
     <entry>Die Anzahl der Zeilen, die der Client von einem durch eine
      vorbereitete Anweisung erstellten Zeiger (Cursor) abruft</entry>
     <entry></entry>
    </row>
    <row>
     <entry><literal>rows_skipped_normal</literal>,
      <literal>rows_skipped_ps</literal></entry>
     <entry>Verbindung</entry>
     <entry>Für zukünftige Verwendung reserviert (wird derzeit nicht
      unterstützt)</entry>
     <entry></entry>
    </row>
    <row>
     <entry><literal>copy_on_write_saved</literal>,
      <literal>copy_on_write_performed</literal></entry>
     <entry>Prozess</entry>
     <entry>Bei mysqlnd zeigen die von den Erweiterungen zurückgegebenen
      Variablen auf die internen Netzwerk-Ergebnispuffer von mysqlnd. Wenn die
      Variablen nicht verändert werden, werden die abgerufenen Daten nur
      einmal im Speicher gehalten. Wenn die Variablen verändert werden, muss
      mysqlnd ein Copy-on-Write (Kopieren beim Schreiben) durchführen, um die
      internen Netzwerk-Ergebnispuffer vor Änderungen zu schützen. Bei der
      MySQL Client Library werden die abgerufenen Daten immer zweimal im
      Speicher gehalten. Einmal in den internen Puffern der MySQL Client
      Library und einmal in den Variablen, die von den Erweiterungen
      zurückgegeben werden. Theoretisch kann mysqlnd bis zu 40% Speicherplatz
      sparen. Allerdings ist zu beachten, dass die Speichereinsparung nicht
      mit <function>memory_get_usage</function> gemessen werden kann.</entry>
     <entry></entry>
    </row>
    <row>
     <entry><literal>explicit_free_result</literal>,
      <literal>implicit_free_result</literal></entry>
     <entry>Verbindung, Prozess (nur während der Bereinigung der
      vorbereiteten Anweisung)</entry>
     <entry>Die Anzahl der freigegebenen Ergebnismengen</entry>
     <entry>Abgesehen von Ergebnismengen, die durch einen init-Befehl erzeugt
      werden, wird das Freigeben immer als explizit betrachtet, &zb;
      <literal>mysqli_options(MYSQLI_INIT_COMMAND , ...)</literal></entry>
    </row>
    <row>
     <entry><literal>proto_text_fetched_null</literal>,
      <literal>proto_text_fetched_bit</literal>,
      <literal>proto_text_fetched_tinyint</literal>
      <literal>proto_text_fetched_short</literal>,
      <literal>proto_text_fetched_int24</literal>,
      <literal>proto_text_fetched_int</literal>
      <literal>proto_text_fetched_bigint</literal>,
      <literal>proto_text_fetched_decimal</literal>,
      <literal>proto_text_fetched_float</literal>
      <literal>proto_text_fetched_double</literal>,
      <literal>proto_text_fetched_date</literal>,
      <literal>proto_text_fetched_year</literal>
      <literal>proto_text_fetched_time</literal>,
      <literal>proto_text_fetched_datetime</literal>,
      <literal>proto_text_fetched_timestamp</literal>
      <literal>proto_text_fetched_string</literal>,
      <literal>proto_text_fetched_blob</literal>,
      <literal>proto_text_fetched_enum</literal>
      <literal>proto_text_fetched_set</literal>,
      <literal>proto_text_fetched_geometry</literal>,
      <literal>proto_text_fetched_other</literal></entry>
     <entry>Verbindung</entry>
     <entry>Die Anzahl der Spalten eines bestimmten Typs, die aus einer
      normalen Abfrage abgerufen wurden (MySQL-Textprotokoll)</entry>
     <entry>Zuordnung zwischen C-API/MySQL-Metadatentypen und Statistiknamen:
      <itemizedlist>
       <listitem>
        <para>
         <literal>MYSQL_TYPE_NULL</literal> - proto_text_fetched_null
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>MYSQL_TYPE_BIT</literal> - proto_text_fetched_bit
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>MYSQL_TYPE_TINY</literal> - proto_text_fetched_tinyint
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>MYSQL_TYPE_SHORT</literal> - proto_text_fetched_short
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>MYSQL_TYPE_INT24</literal> - proto_text_fetched_int24
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>MYSQL_TYPE_LONG</literal> - proto_text_fetched_int
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>MYSQL_TYPE_LONGLONG</literal> -
         proto_text_fetched_bigint
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>MYSQL_TYPE_DECIMAL</literal>,
         <literal>MYSQL_TYPE_NEWDECIMAL</literal> -
         proto_text_fetched_decimal
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>MYSQL_TYPE_FLOAT</literal> - proto_text_fetched_float
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>MYSQL_TYPE_DOUBLE</literal> -
         proto_text_fetched_double
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>MYSQL_TYPE_DATE</literal>,
         <literal>MYSQL_TYPE_NEWDATE</literal> - proto_text_fetched_date
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>MYSQL_TYPE_YEAR</literal> - proto_text_fetched_year
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>MYSQL_TYPE_TIME</literal> - proto_text_fetched_time
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>MYSQL_TYPE_DATETIME</literal> -
         proto_text_fetched_datetime
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>MYSQL_TYPE_TIMESTAMP</literal> -
         proto_text_fetched_timestamp
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>MYSQL_TYPE_STRING</literal>,
         <literal>MYSQL_TYPE_VARSTRING</literal>,
         <literal>MYSQL_TYPE_VARCHAR</literal> -
         proto_text_fetched_string
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>MYSQL_TYPE_TINY_BLOB</literal>,
         <literal>MYSQL_TYPE_MEDIUM_BLOB</literal>,
         <literal>MYSQL_TYPE_LONG_BLOB</literal>,
         <literal>MYSQL_TYPE_BLOB</literal> - proto_text_fetched_blob
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>MYSQL_TYPE_ENUM</literal> - proto_text_fetched_enum
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>MYSQL_TYPE_SET</literal> - proto_text_fetched_set
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>MYSQL_TYPE_GEOMETRY</literal> -
         proto_text_fetched_geometry
        </para>
       </listitem>
       <listitem>
        <para>
         Alle hier nicht aufgeführten <literal>MYSQL_TYPE_*</literal> (es
         sollte keine geben) - proto_text_fetched_other
        </para>
       </listitem>
      </itemizedlist>
      <para>
       Es ist zu beachten, dass die MYSQL_*-Typ-Konstanten nicht in jeder
       MySQL-Version mit denselben SQL-Spaltentypen verknüpft sein müssen.
      </para></entry>
    </row>
    <row>
     <entry><literal>proto_binary_fetched_null</literal>,
      <literal>proto_binary_fetched_bit</literal>,
      <literal>proto_binary_fetched_tinyint</literal>
      <literal>proto_binary_fetched_short</literal>,
      <literal>proto_binary_fetched_int24</literal>,
      <literal>proto_binary_fetched_int</literal>,
      <literal>proto_binary_fetched_bigint</literal>,
      <literal>proto_binary_fetched_decimal</literal>,
      <literal>proto_binary_fetched_float</literal>,
      <literal>proto_binary_fetched_double</literal>,
      <literal>proto_binary_fetched_date</literal>,
      <literal>proto_binary_fetched_year</literal>,
      <literal>proto_binary_fetched_time</literal>,
      <literal>proto_binary_fetched_datetime</literal>,
      <literal>proto_binary_fetched_timestamp</literal>,
      <literal>proto_binary_fetched_string</literal>,
      <literal>proto_binary_fetched_blob</literal>,
      <literal>proto_binary_fetched_enum</literal>,
      <literal>proto_binary_fetched_set</literal>,
      <literal>proto_binary_fetched_geometry</literal>,
      <literal>proto_binary_fetched_other</literal></entry>
     <entry>Verbindung</entry>
     <entry>Die Anzahl der Spalten eines bestimmten Typs, die aus einer
      vorbereiteten Anweisung abgerufen wurden (MySQL-Binärprotokoll)</entry>
     <entry>Für die Zuordnung der Typen siehe die Beschreibung von
      <literal>proto_text_*</literal> im vorhergehenden Punkt.</entry>
    </row>
   </tbody>
  </tgroup>
 </table>
 <table xml:id="mysqlnd.stats.connection">
  <title>Von mysqlnd zurückgegebene Statistiken: Verbindung</title>
  <tgroup cols="4">
   <colspec colwidth="10*"/>
   <colspec colwidth="10*"/>
   <colspec colwidth="40*"/>
   <colspec colwidth="40*"/>
   <thead>
    <row>
     <entry>Statistik</entry>
     <entry>Bereich</entry>
     <entry>&Description;</entry>
     <entry>Hinweise</entry>
    </row>
   </thead>
   <tbody>
    <row>
     <entry><literal>connect_success</literal>, <literal>connect_failure</literal></entry>
     <entry>Verbindung</entry>
     <entry>Die Anzahl der erfolgreichen/fehlgeschlagenen Verbindungsversuche</entry>
     <entry>Wiederverwendete Verbindungen und alle anderen Arten von
      Verbindungen sind darin enthalten.</entry>
    </row>
    <row>
     <entry><literal>reconnect</literal></entry>
     <entry>Prozess</entry>
     <entry>Die Anzahl der (real_)connect-Versuche an einem bereits geöffneten
      Verbindungshandle</entry>
     <entry>Die Codesequenz <literal>$link = new mysqli(...);
      $link-&gt;real_connect(...)</literal> führt zu einem Wiederaufbau einer
      Verbindung. <literal>$link = new mysqli(...);
      $link-&gt;connect(...)</literal> hingegen nicht, weil
      <literal>$link-&gt;connect(...)</literal> die bestehende Verbindung
      explizit schließt, bevor eine neue Verbindung aufgebaut wird.</entry>
    </row>
    <row>
     <entry><literal>pconnect_success</literal></entry>
     <entry>Verbindung</entry>
     <entry>Die Anzahl der erfolgreichen Versuche, eine persistente
      (dauerhafte) Verbindung herzustellen</entry>
     <entry>Es ist zu beachten, dass <literal>connect_success</literal> die
      Summe der erfolgreichen persistenten und nicht-persistenten
      Verbindungsversuche enthält. Die Anzahl der erfolgreichen
      nicht-persistenten Verbindungsversuche ist
      <literal>connect_success</literal> -
      <literal>pconnect_success</literal>.</entry>
    </row>
    <row>
     <entry><literal>active_connections</literal></entry>
     <entry>Verbindung</entry>
     <entry>Die Anzahl der aktiven Verbindungen (persistent und nicht-persistent)</entry>
     <entry></entry>
    </row>
    <row>
     <entry><literal>active_persistent_connections</literal></entry>
     <entry>Verbindung</entry>
     <entry>Die Anzahl der aktiven persistenten Verbindungen</entry>
     <entry>Die Anzahl der nicht-persistenten Verbindungen ist
      <literal>active_connections</literal> -
      <literal>active_persistent_connections</literal>.</entry>
    </row>
    <row>
     <entry><literal>explicit_close</literal></entry>
     <entry>Verbindung</entry>
     <entry>Die Anzahl der explizit geschlossenen Verbindungen (nur ext/mysqli)</entry>
     <entry>Beispiele für Codeschnipsel, die zu einem expliziten Schließen führen:
      <programlisting>
<![CDATA[
$link = new mysqli(...); $link->close(...)
$link = new mysqli(...); $link->connect(...)
]]>
      </programlisting></entry>
    </row>
    <row>
     <entry><literal>implicit_close</literal></entry>
     <entry>Verbindung</entry>
     <entry>Die Anzahl der implizit geschlossenen Verbindungen (nur ext/mysqli)</entry>
     <entry>Beispiele für Codeschnipsel, die zu einem impliziten Schließen führen:
      <itemizedlist>
       <listitem>
        <para>
         <literal>$link = new mysqli(...);
         $link-&gt;real_connect(...)</literal>
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>unset($link)</literal>
        </para>
       </listitem>
       <listitem>
        <para>
         persistente Verbindung: eine gepoolte Verbindung wurde mit
         real_connect erstellt und es können unbekannte Optionen gesetzt sein
         - implizites Schließen, um die Rückgabe einer Verbindung mit
         unbekannten Optionen zu vermeiden
        </para>
       </listitem>
       <listitem>
        <para>
         persistente Verbindung: ping/change_user schlägt fehl und ext/mysqli
         schließt die Verbindung
        </para>
       </listitem>
       <listitem>
        <para>
         am Ende der Skriptausführung: Schließen der Verbindungen, die noch
         nicht vom Benutzer geschlossen wurden
        </para>
       </listitem>
      </itemizedlist></entry>
    </row>
    <row>
     <entry><literal>disconnect_close</literal></entry>
     <entry>Verbindung</entry>
     <entry>Die Anzahl der fehlgeschlagenen Verbindungen, die der C-API-Aufruf
      <function>mysql_real_connect</function> beim Versuch, eine Verbindung
      aufzubauen, meldet</entry>
     <entry>Diese Statistik heißt <literal>disconnect_close</literal>, weil
      das an den C-API-Aufruf übergebene Verbindungshandle geschlossen
      wird.</entry>
    </row>
    <row>
     <entry><literal>in_middle_of_command_close</literal></entry>
     <entry>Prozess</entry>
     <entry>Eine Verbindung wurde mitten in der Ausführung eines Befehls
      geschlossen (noch nicht abgerufene Ergebnismengen, nachdem eine Abfrage
      gesendet und bevor eine Antwort abgerufen wurde, während Daten abgerufen
      wurden, während Daten mit LOAD DATA übertragen wurden)</entry>
     <entry>Sofern keine asynchronen Abfragen verwendet werden, sollte dies
      nur passieren, wenn ein Skript unerwartet gestoppt wird und PHP die
      Verbindungen automatisch schließt.</entry>
    </row>
    <row>
     <entry><literal>init_command_executed_count</literal></entry>
     <entry>Verbindung</entry>
     <entry>Die Anzahl der ausgeführten init-Befehle, zum Beispiel
      <literal>mysqli_options(MYSQLI_INIT_COMMAND , ...)</literal>.</entry>
     <entry>Die Anzahl der erfolgreichen Ausführungen ist
      <literal>init_command_executed_count</literal> -
      <literal>init_command_failed_count</literal>.</entry>
    </row>
    <row>
     <entry><literal>init_command_failed_count</literal></entry>
     <entry>Verbindung</entry>
     <entry>Die Anzahl der fehlgeschlagenen init-Befehle</entry>
     <entry></entry>
    </row>
   </tbody>
  </tgroup>
 </table>
 <table xml:id="mysqlnd.stats.com">
  <title>Von mysqlnd zurückgegebene Statistiken: COM_*-Befehl</title>
  <tgroup cols="4">
   <colspec colwidth="10*"/>
   <colspec colwidth="10*"/>
   <colspec colwidth="40*"/>
   <colspec colwidth="40*"/>
   <thead>
    <row>
     <entry>Statistik</entry>
     <entry>Bereich</entry>
     <entry>&Description;</entry>
     <entry>Hinweise</entry>
    </row>
   </thead>
   <tbody>
    <row>
     <entry><literal>com_quit</literal>, <literal>com_init_db</literal>,
      <literal>com_query</literal>, <literal>com_field_list</literal>,
      <literal>com_create_db</literal>, <literal>com_drop_db</literal>,
      <literal>com_refresh</literal>, <literal>com_shutdown</literal>,
      <literal>com_statistics</literal>,
      <literal>com_process_info</literal>,
      <literal>com_connect</literal>,
      <literal>com_process_kill</literal>, <literal>com_debug</literal>,
      <literal>com_ping</literal>, <literal>com_time</literal>,
      <literal>com_delayed_insert</literal>,
      <literal>com_change_user</literal>,
      <literal>com_binlog_dump</literal>,
      <literal>com_table_dump</literal>,
      <literal>com_connect_out</literal>,
      <literal>com_register_slave</literal>,
      <literal>com_stmt_prepare</literal>,
      <literal>com_stmt_execute</literal>,
      <literal>com_stmt_send_long_data</literal>,
      <literal>com_stmt_close</literal>,
      <literal>com_stmt_reset</literal>,
      <literal>com_stmt_set_option</literal>,
      <literal>com_stmt_fetch</literal>, <literal>com_daemon</literal></entry>
     <entry>Verbindung</entry>
     <entry>Die Anzahl der Versuche, einen bestimmten COM_*-Befehl von PHP an
      MySQL zu senden</entry>
     <entry><para>
       Die Statistik wird erhöht, nachdem die Zeile geprüft wurde und
       unmittelbar bevor das entsprechende MySQL-Client-Server-Protokoll-Paket
       gesendet wird. Die Statistik wird nicht nach unten korrigiert, wenn
       mysqlnd das Paket nicht über die Leitung senden kann. Im Falle eines
       Fehlers gibt mysqlnd die PHP-Warnung <quote>Error while sending %s
       packet. PID=%d.</quote> aus.
      </para>

      <para>
       Beispiele für die Verwendung:
      </para>
      <itemizedlist>
       <listitem>
        <para>
         Überprüfen, ob PHP bestimmte Befehle an MySQL sendet, zum Beispiel,
         ob ein Client <literal>COM_PROCESS_KILL</literal> sendet
        </para>
       </listitem>
       <listitem>
        <para>
         Berechnen der durchschnittlichen Anzahl der ausgeführten
         vorbereiteten Anweisungen durch Vergleich von
         <literal>COM_EXECUTE</literal> und <literal>COM_PREPARE</literal>
        </para>
       </listitem>
       <listitem>
        <para>
         Überprüfen, ob PHP nicht-vorbereitete SQL-Anweisungen ausgeführt
         hat, indem kontrolliert wird, ob <literal>COM_QUERY</literal> Null
         ist
        </para>
       </listitem>
       <listitem>
        <para>
         Erkennen von PHP-Skripten, die eine zu große Anzahl von
         SQL-Anweisungen ausführen, indem <literal>COM_QUERY</literal> und
         <literal>COM_EXECUTE</literal> überprüft werden
        </para>
       </listitem>
      </itemizedlist></entry>
    </row>
   </tbody>
  </tgroup>
 </table>
 <para>
  <emphasis role="bold">Sonstige</emphasis>
 </para>
 <table xml:id="mysqlnd.stats.misc">
  <title>Von mysqlnd zurückgegebene Statistiken: Sonstige</title>
  <tgroup cols="4">
   <colspec colwidth="10*"/>
   <colspec colwidth="10*"/>
   <colspec colwidth="40*"/>
   <colspec colwidth="40*"/>
   <thead>
    <row>
     <entry>Statistik</entry>
     <entry>Bereich</entry>
     <entry>&Description;</entry>
     <entry>Hinweise</entry>
    </row>
   </thead>
   <tbody>
    <row>
     <entry><literal>explicit_stmt_close</literal>,
      <literal>implicit_stmt_close</literal></entry>
     <entry>Prozess</entry>
     <entry>Die Anzahl der abgeschlossenen vorbereiteten Anweisungen</entry>
     <entry>Ein Abschluss gilt immer als explizit, außer wenn die
      Vorbereitung fehlgeschlagen ist.</entry>
    </row>
    <row>
     <entry><literal>mem_emalloc_count</literal>,
      <literal>mem_emalloc_ammount</literal>,
      <literal>mem_ecalloc_count</literal>,
      <literal>mem_ecalloc_ammount</literal>,
      <literal>mem_erealloc_count</literal>,
      <literal>mem_erealloc_ammount</literal>,
      <literal>mem_efree_count</literal>,
      <literal>mem_malloc_count</literal>,
      <literal>mem_malloc_ammount</literal>,
      <literal>mem_calloc_count</literal>,
      <literal>mem_calloc_ammount</literal>,
      <literal>mem_realloc_count</literal>,
      <literal>mem_realloc_ammount</literal>,
      <literal>mem_free_count</literal></entry>
     <entry>Prozess</entry>
     <entry>Die Anzahl der Aufrufe bezüglich Speicherverwaltung</entry>
     <entry>Nur für die Entwicklung</entry>
    </row>
    <row>
     <entry><literal>command_buffer_too_small</literal></entry>
     <entry>Verbindung</entry>
     <entry>Die Anzahl der Erweiterungen des Netzwerk-Befehlspuffers, wenn PHP
      einen Befehl an MySQL sendet</entry>
     <entry><para>
       mysqlnd weist jeder Verbindung einen internen Befehls-/Netzwerkpuffer
       von <literal>mysqlnd.net_cmd_buffer_size</literal>
       (<filename>php.ini</filename>) Bytes zu. Wenn ein Befehl des
       MySQL-Client-Server-Protokolls, &zb; <literal>COM_QUERY</literal>
       (normale Abfrage), nicht in den Puffer passt, vergrößert mysqlnd den
       Puffer auf die Größe, die zum Senden des Befehls erforderlich ist.
       Jedes Mal, wenn der Puffer für eine Verbindung vergrößert wird, wird
       <literal>command_buffer_too_small</literal> um eins erhöht.
      </para>

      <para>
       Wenn mysqlnd den Puffer bei fast jeder Verbindung über seine
       anfängliche Größe von <literal>mysqlnd.net_cmd_buffer_size</literal>
       (<filename>php.ini</filename>) Bytes hinaus vergrößern muss, sollte in
       Erwägung gezogen werden, die Standardgröße zu erhöhen, um
       Neuzuweisungen zu vermeiden.
      </para>

      <para>
       Die voreingestellte Puffergröße beträgt 4096 Bytes, was der
       kleinstmögliche Wert ist. Dieser Wert kann entweder in der
       <filename>php.ini</filename> durch die Einstellung
       <literal>mysqlnd.net_cmd_buffer_size</literal> geändert werden oder
       durch <literal>mysqli_options(MYSQLI_OPT_NET_CMD_BUFFER_SIZE, int
       size)</literal>.
      </para></entry>
    </row>
    <row>
     <entry><literal>connection_reused</literal></entry>
     <entry></entry>
     <entry></entry>
     <entry></entry>
    </row>
   </tbody>
  </tgroup>
 </table>
</chapter>
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
